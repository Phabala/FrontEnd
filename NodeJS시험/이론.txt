1. 모듈이란 애플리케이션을 구성하는 개별적 요소로서 재사용 가능한 코드 조각을 말한다. 이 때 모듈이 성립하려면 모듈은 자신만의 파일 스코프(모듈 스코프)를 가질 수 있어야 한다.  모듈은 개별적 존재로서 애플리케이션과 분리되어 존재하지만 애플리케이션과 완전히 분리되어 개별적으로 존재하는 모듈은 재사용이 불가하므로 존재의 의미가 없다. 모듈은 애플리케이션이나 다른 모듈에 의해 재사용되어야 의미가 있다. 따라서 모듈은 공개가 필요한 자산에 한정하여 명시적으로 선택적 공개가 가능한데 이를 export라 한다. 모듈사용자는 모듈이 공개한 자산 중 일부 또는 전체를 선택해 자신의 스코프 태로 불러들여 재사용할 수 있다. 이를 import라 한다. 이처럼 모듈은 애플리케이션과 분리되어 개별적으로 존재하다가 필요에 따라 다른 모듈에 의해 재사용된다. 모듈은 기능별로 분리되어 개별적인 파일로 작성된다. 따라서 <<코드의 단위를 명확히 분리하여 애플리케이션을 구성(네임스페이스화)>>할 수 있고, <<재사용성>>이 좋아서 <<개발 효율성>>과 <<유지보수성>>을 높일 수 있다.
2. Express의 의미: Express는 Node.js 를 위한 빠르고 개방적이고 간결한 웹 프레임워크로, 파이썬의 Django, Java의 Spring 프레잌워크처럼 javascript에서 사용하는 웹 프레임워크의 종류 중 하나다.
Express를 사용하는 이유: Express는 코드의 양을 줄여주고 추후에 유지보수를 쉽게 하도록 만들어주며 EJS 템플릿 엔진을 사용할 수 있게 해준다.
3. 미들웨어는 광범위한 의미로 서로 다른 애플리케이션이 서로 통신하는데 사용하는 소프트웨어고, node.js 에서의 좁은 의미로는 req(요청) 객체, res(응답)객체, 그리고 어플리케이션 요청-응답 사이클 도중 그 다음의 미들웨어 함수에 대한 엑세스 권한을 갖는 함수이다. 간단하게 말하면 클라이언트에게 요청이 오고 그 요청을 보내기 위해 응답하려는 중간(미들)에 목적에 맞게 처리하고 거쳐가는 함수다. 다음 미들웨어 함수에 대한 엑세스는 next 함수를 이용해 다음 미들웨어로 현재의 요청을 넘길 수 있고, next를 통해 미들웨어들이 순차적으로 처리된다.
4. 라우터는 클라이언트의 요청 경로(path)를 보고 이 요청을 처리할 수 있는 곳으로 기능을 전달해주는 역할을 한다. 이 역할을 라우팅이라고 하는데, 라우팅은 URI(또는 경로) 및 특정한 HTTP 요청 메소드(get, post … ) 인 특정 엔드포인트에 대한 클라이언트 요청에 애플리케이션이 응답하는 방법을 결정하는 것이다.
라우팅 방식: 라우팅은 크게 정적 라우팅과 동적 라우팅으로 나뉜다.

정적 라우팅 방식은 네트워크 관리자가 패킷의 경로를 임의로 결정하여 수동으로 구성하는 라우팅 방식이다.
장점: 라우터의 부하를 경감할 수 있다. 복잡한 계산이 필요 없으므로 빠른 라우팅이 가능하다.
단점: 관리자가 관리해야 할 부분이 많아진다, 네트워크 환경 변화를 고려하지 않는다, 정해진 경로 상에서 장애가 발생할 경우 네트워크 전체 이용에 장애가 발생할 수 있다, 네트워크 규모가 커지면 수동으로 추가하기 위해 시간이 많이 든다.

동적 라우팅 방식은 라우터가 라우팅 프로토콜에 의한 계산에 따라 스스로 라우팅 경로를 결정하는 방식이다.
장점: 작업 부담이 없고 항상 최신 라우팅 정보를 유지할 수 있다. 네트워크 환경 변화를 고려한다.
단점: 라우터의 부하가 크다.

라우터를 사용하는 이유: path의 흐름을 간결하게 정리할 수 있다.
5. form 태그의 3가지 조건과 의미:
1) 폼 데이터를 전송할 서버 url: action = “”
2) 폼의 이름 name = “”
3) 전송방식(get/post) type = “”
6.
GET 방식 : 클라이언트에서 서버로 데이터를 전달할 때, 주소 뒤에 “이름”과 “값”이 결합된 스트링 형태로 전달, 주소창에 쿼리 스트링이 그대로 보이기 때문에 보안성이 떨어진다, 길이에 제한이 있다, Post 방식보다 상대적으로 전송 속도가 빠르다.
POST 방식 : 일정 크기 이상의 데이터를 보내야 할 때 사용한다, 서버로 보내기 전에 인코딩하고, 전송 후 서버에서 다시 디코딩 작업을 한다, 주소창에 전송하는 데이터의 정보가 노출되지 않아 Get방식에 비해 보안성이 높다, 속도가 Get방식에 비해 상대적으로 느리다, 쿼리스트링(문자열) 데이터 뿐만 아니라, 라디오 버튼, 텍스트 박스 같은 객체들의 값도 전송이 가능하다.
7. 세션은 쿠키보다 더 안전하고 많은 데이터를 저장하는 저장 방식이다. 쿠키의 경우 데이터를 사용자의 컴퓨터에 저장하기 때문에 비밀번호 같은 민감한 부분이라도 예외 없이 그대로 드러난다. 하지만 세션은 <<데이터를 서버에 저장하기 때문에 쿠키보다 안전>>하다고 볼 수 있다. 
8. 
render : 템플릿을 불러옴 
redirect : URL로 이동

9.
A: message_member 테이블에서 email이 이 post로 요청받은 body 데이터의 email 값, pw가 post로 요청받은 body의 pw값인 (and조건) 행(row)의 모든 열(column)들을 선택한다.
B: 세션의 유저 데이터에 로그인에 성공한 유저의 정보를 객체로 저장한다. 객체의 key 는 email, phone, address 이며 각각의 value 는 로그인 한 유저의 정보를 데이터베이스에서 가져온 email, phone, address 이다.
C: Message 템플릿을 렌더링하여 클라이언트에게 전송하며, Message 템플릿에 객체 { user : request.session.user } 를 전달한다.
